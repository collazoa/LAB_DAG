estimate_unbiased[[i]]<-exploratory_data[[i]]$estimate_unbiased[1]}
vec_estimate_unbiased<-as.vector(unlist(estimate_unbiased))
estimates<-data.frame(baseline_adj_coef = vec_baseline_adj_coef,
coef_biased = vec_coef_biased,
estimate_biased = vec_estimate_biased,
estimate_unbiased = vec_estimate_unbiased)
summary_estimates<-data.frame(diff_adj_unbiased = estimates$estimate_unbiased - estimates$baseline_adj_coef,
diff_unadj_unbiased = estimates$estimate_unbiased - estimates$coef_biased)
mean_estimates<-data.frame(mean_diff_adj_unbiased = mean(summary_estimates$diff_adj_unbiased),
mean_diff_unadj_unbiased = mean(summary_estimates$diff_unadj_unbiased))
summary_measures<-rbind(round(summary(estimates$coef_biased),1),
round(summary(estimates$baseline_adj_coef),1),
round(summary(estimates$estimate_unbiased),1))
View(summary_measures)
rownames(summary_measures)<-c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate")
kable(summary_measures)%>%kable_classic()
apply(naive_estimate, 1, summary)
range<-data.frame(rbind(round(summary(estimates$coef_biased),1),
round(summary(estimates$baseline_adj_coef),1),
round(summary(estimates$estimate_unbiased),1)))%>%
select(c(2,3,5))%>%
mutate(coefficient = c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate"))%>%
rename(c("First", "Median", "Third", "coefficient"))
range<-data.frame(rbind(round(summary(estimates$coef_biased),1),
round(summary(estimates$baseline_adj_coef),1),
round(summary(estimates$estimate_unbiased),1)))%>%
select(c(2,3,5))%>%
mutate(coefficient = c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate"))%>%
rename(c("First", "Median", "Third", "coefficient"))
range<-data.frame(rbind(round(summary(estimates$coef_biased),1),
round(summary(estimates$baseline_adj_coef),1),
round(summary(estimates$estimate_unbiased),1)))
range<-range%>% select(c(2,3,5))%>%
mutate(coefficient = c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate"))%>%
rename(c("First", "Median", "Third", "coefficient"))
View(range)
range%>% select(c(2,3,5))
range%>% select(c(2,3,5))%>%
mutate(coefficient = c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate"))
range<-range%>% select(c(2,3,5))%>%
mutate(coefficient = c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate"))
ggplot(range, aes(x= coefficient, y = Median)) +
geom_point(size = 3) +
geom_errorbar(aes(ymax = X3rd.Qu., ymin = X1st.Qu., width = 0.2))+
geom_hline(yintercept = 0, linetype = "longdash", alpha = 0.5, color = "red")+
labs(y = "median and interquartile range of estimated coefficient ",
x = "")+
theme(axis.ticks.y = element_blank(),
panel.grid.minor = element_blank(),
panel.grid.major = element_blank())
set.seed(5)
exploratory_data <- list()
for(b in 1: n_exp) {
for ( i in 1:nrow(report)) {
dat <- data.frame(A = rep(0:1,report$prob_A[i]*report$n[i], each=1),
L = rnorm(n=report$n[i], mean=report$mean_L[i], sd=report$sd_L[i]))
dat$W <- report$g_0[i] + report$g_1[i]*dat$A + report$g_2[i]*dat$L + rnorm(report$n[i], 0, report$sd_W[i])
dat$Y <- report$b_0[i] + report$b_1[i]*dat$A + report$b_2[i]*dat$L + rnorm(report$n[i], 0, report$sd_Y[i])
dat$W2 <- dat$W >= quantile(dat$W, probs=report$cutoff_W[i])
dat$A <- as.factor(dat$A)
dat_s <- dat %>% filter(W2==TRUE)
#estimate in the censored data-set
estimate_biased[i] <-  mean(dat_s$Y[dat_s$A==1]) - mean(dat_s$Y[dat_s$A==0])
estimate_unbiased[i]<- mean(dat$Y[dat$A ==1]- mean(dat$Y[dat$A == 0]))
#perform a linear regression in the censored dataset
#without correcting for baselin stroke volume
model1<-lm(dat_s$Y ~ dat_s$A, data = dat_s)
coef_biased[i]<-model1$coefficients[2]
#while correcting for baseline stroke volume (dat$L)
model2<-lm(dat_s$Y ~ dat_s$A + dat_s$L, data = dat_s)
baseline_adj_coef[i] <-model2$coefficients[2]
report$coef_biased[i] <-coef_biased[i]
report$baseline_adj_coef[i]<-baseline_adj_coef[i]
report$estimate_biased[i] <-estimate_biased[i]
report$estimate_unbiased[i]<-estimate_unbiased[i]
}
exploratory_data[[b]]<-report
}
#extraction of coefficients from simulation
coef_biased<-list()
for (i in 1:length(exploratory_data)) {
coef_biased[[i]]<-exploratory_data[[i]]$coef_biased[1]}
vec_coef_biased<-as.vector(unlist(coef_biased))
baseline_adj_coef<-list()
for (i in 1:length(exploratory_data)) {
baseline_adj_coef[[i]]<-exploratory_data[[i]]$baseline_adj_coef[1]}
vec_baseline_adj_coef<-as.vector(unlist(baseline_adj_coef))
estimate_biased<-list()
for (i in 1:length(exploratory_data)) {
estimate_biased[[i]]<-exploratory_data[[i]]$estimate_biased[1]}
vec_estimate_biased<-as.vector(unlist(estimate_biased))
estimate_unbiased<-list()
for (i in 1:length(exploratory_data)) {
estimate_unbiased[[i]]<-exploratory_data[[i]]$estimate_unbiased[1]}
vec_estimate_unbiased<-as.vector(unlist(estimate_unbiased))
# creating dataframe from coefficient values
estimates<-data.frame(baseline_adj_coef = vec_baseline_adj_coef,
coef_biased = vec_coef_biased,
estimate_biased = vec_estimate_biased,
estimate_unbiased = vec_estimate_unbiased)
summary_estimates<-data.frame(diff_adj_unbiased = estimates$estimate_unbiased - estimates$baseline_adj_coef,
diff_unadj_unbiased = estimates$estimate_unbiased - estimates$coef_biased)
mean_estimates<-data.frame(mean_diff_adj_unbiased = mean(summary_estimates$diff_adj_unbiased),
mean_diff_unadj_unbiased = mean(summary_estimates$diff_unadj_unbiased))
#summary tables
summary_measures<-rbind(round(summary(estimates$coef_biased),1),
round(summary(estimates$baseline_adj_coef),1),
round(summary(estimates$estimate_unbiased),1))
rownames(summary_measures)<-c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate")
kable(summary_measures)%>%kable_classic()
#visualization
#coefficient ranges
range<-data.frame(rbind(round(summary(estimates$coef_biased),1),
round(summary(estimates$baseline_adj_coef),1),
round(summary(estimates$estimate_unbiased),1)))
range<-range%>% select(c(2,3,5))%>%
mutate(coefficient = c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate"))
ggplot(range, aes(x= coefficient, y = Median)) +
geom_point(size = 3) +
geom_errorbar(aes(ymax = X3rd.Qu., ymin = X1st.Qu., width = 0.2))+
geom_hline(yintercept = 0, linetype = "longdash", alpha = 0.5, color = "red")+
labs(y = "median and interquartile range of estimated coefficient ",
x = "")+
theme(axis.ticks.y = element_blank(),
panel.grid.minor = element_blank(),
panel.grid.major = element_blank())
#converting estimates table to long format
long_estimates<-gather(estimates, key = "coefficient", value = "value", c(baseline_adj_coef, coef_biased,estimate_unbiased))
#density plots for the estimates
ggplot(long_estimates, aes(value, fill = coefficient)) +
geom_density(alpha = 0.2)+
geom_vline(xintercept = c(-50,0, 50), linetype = c("longdash", "solid", "longdash"), color = c("grey", "black", "grey"), size = 1)+
scale_fill_manual(values = c("#0072B2", "goldenrod1", "plum4"),
name = "coefficients",
labels= c("baseline-adjusted censored dataset", "censored dataset", "complete dataset"))+
labs(title = "Estimated values for treatment effect from simulated experiments",
subtitle = "Coefficient value for treatment effect in complete sample, censored sample and baseline-adjusted censored sample",
x= "coefficient value")+
theme(legend.position = "bottom",
panel.background = element_blank(),
axis.line = element_line())
#density plot: zoomed in to values x(-10,10)
View(range)
range<-data.frame(rbind(round(summary(naive_estimate),1),
round(summary(adjusted_mod_estimate),1),
round(summary(no_exclusion_estimate),1)))
range<-range%>% select(c(2,3,5))%>%
mutate(coefficient = c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate"))
range<-data.frame(rbind(round(summary(naive_estimate),1),
round(summary(adjusted_mod_estimate),1),
round(summary(no_exclusion_estimate),1)))
View(range)
(summary(naive_estimate)
)
summary(naive_estimate)
apply(naive_estimate,1, summary)
range<-data.frame(rbind(round(apply(naive_estimate,1, summary),1),
round(apply(adjusted_mod_estimate,1, summary),1),
round(apply(no_exclusion_estimate,1, summary),1)))
View(range)
round(apply(adjusted_mod_estimate,1, summary),1),
round(apply(no_exclusion_estimate,1, summary),1)))
View(range)
apply(naive_estimate, 1, summary)
apply(naive_estimate[1,], 1, summary)
naive_estimate[1,]
apply(naive_estimate[1,], 1, summary)
naive_estimate[,1]
apply(naive_estimate, 1, summary)
apply(naive_estimate, 1, quantile(0.25))
apply(naive_estimate, 1, quantile(probs = 0.25))
apply(naive_estimate, 1, quantile(naive_estimate,probs = 0.25))
range<-data.frame(rbind(round(summary(estimates$coef_biased),1),
round(summary(estimates$baseline_adj_coef),1),
round(summary(estimates$estimate_unbiased),1)))
range<-range%>% select(c(2,3,5))%>%
mutate(coefficient = c("biased coefficient", "baseline-adjusted coefficient", "unbiased estimate"))
ggplot(range, aes(x= coefficient, y = Median)) +
geom_point(size = 3) +
geom_errorbar(aes(ymax = X3rd.Qu., ymin = X1st.Qu., width = 0.2))+
geom_hline(yintercept = 0, linetype = "longdash", alpha = 0.5, color = "red")+
labs(y = "median and interquartile range of estimated coefficient ",
x = "")+
theme(axis.ticks.y = element_blank(),
panel.grid.minor = element_blank(),
panel.grid.major = element_blank())
#converting estimates table to long format
long_estimates<-gather(estimates, key = "coefficient", value = "value", c(baseline_adj_coef, coef_biased,estimate_unbiased))
ggplot(long_estimates, aes(value, fill = coefficient)) +
geom_density(alpha = 0.2)+
geom_vline(xintercept = c(-50,0, 50), linetype = c("longdash", "solid", "longdash"), color = c("grey", "black", "grey"), size = 1)+
scale_fill_manual(values = c("#0072B2", "goldenrod1", "plum4"),
name = "coefficients",
labels= c("baseline-adjusted censored dataset", "censored dataset", "complete dataset"))+
labs(title = "Estimated values for treatment effect from simulated experiments",
subtitle = "Coefficient value for treatment effect in complete sample, censored sample and baseline-adjusted censored sample",
x= "coefficient value")+
theme(legend.position = "bottom",
panel.background = element_blank(),
axis.line = element_line())
ggplot(long_estimates, aes(value, color= coefficient)) +
geom_density(alpha = 0.2)+
coord_cartesian(xlim = c(-5,5))+
geom_vline(xintercept = c(mean(estimates$baseline_adj_coef),mean(estimates$coef_biased),mean(estimates$estimate_unbiased)),
color = c("#0072B2", "goldenrod1", "plum4"))+
scale_color_manual(values = c("#0072B2", "goldenrod1", "plum4"),
name = "coefficients",
labels= c("baseline-adjusted censored dataset", "censored dataset", "complete dataset"))+
theme(legend.position = "bottom",
panel.background = element_blank(),
axis.line = element_line())+
labs(title = "Estimated values for treatment effect from simulated experiments",
subtitle = "Coefficient value for treatment effect in complete sample, censored sample and baseline-adjusted censored sample",
x= "coefficient value")
#standard deviation
apply(naive_estimate, 1, sd)
apply(no_exclusion_estimate,1,sd)
apply(adjusted_mod_estimate, 1,sd)
df<-data.frame(mean_naive_estimate = round(apply(naive_estimate, 1, mean),2),
mean_no_exclusion_estimate = round(apply(no_exclusion_estimate, 1, mean),2),
mean_adjusted_mod_estimate = round(apply(adjusted_mod_estimate, 1, mean),2),
side_effects = c("minor", "major"))
df_long<-df%>%gather(key = model, value = estimate, mean_naive_estimate:mean_adjusted_mod_estimate)
ggplot(df_long) +
geom_point(aes(x = side_effects, y = estimate, color = model))+
scale_color_manual(values = c("#0072B2", "goldenrod1", "plum4"),
name = "coefficient for: treatment -> final infarct size",
labels= c("baseline-adjusted censored model", "censored model", "complete model"))+
geom_hline(yintercept = 0, linetype = "dashed", color = "red")+
labs(title = "Estimated values for treatment effect from simulated experiments",
subtitle = "Coefficient value for treatment effect in complete sample, censored sample and baseline-adjusted censored sample",
x= "")+
theme_classic()
ggplot(long_estimates, aes(value, fill = coefficient)) +
geom_density(alpha = 0.2)+
geom_vline(xintercept = c(-50,0, 50), linetype = c("longdash", "solid", "longdash"), color = c("grey", "black", "grey"), size = 1)+
scale_fill_manual(values = c("#0072B2", "goldenrod1", "plum4"),
name = "coefficients",
labels= c("baseline-adjusted censored dataset", "censored dataset", "complete dataset"))+
labs(title = "Estimated values for treatment effect from simulated experiments",
subtitle = "Coefficient value for treatment effect in complete sample, censored sample and baseline-adjusted censored sample",
x= "coefficient value")+
theme(legend.position = "bottom",
panel.background = element_blank(),
axis.line = element_line())
ggplot(df_long) +
geom_point(aes(x = side_effects, y = estimate, color = model))+
scale_color_manual(values = c("#0072B2", "goldenrod1", "plum4"),
name = "coefficient for: treatment -> final infarct size",
labels= c("baseline-adjusted censored model", "censored model", "complete model"))+
geom_hline(yintercept = 0, linetype = "dashed", color = "red")+
labs(title = "Estimated values for treatment effect from simulated experiments",
subtitle = "Coefficient value for treatment effect in complete sample, censored sample and baseline-adjusted censored sample",
x= "")+
theme_classic()
#standard deviation
apply(naive_estimate, 1, sd)
# assess bias
apply(naive_estimate, 1, mean)
apply(no_exclusion_estimate, 1, mean)
apply(adjusted_mod_estimate, 1, mean)
hist(naive_estimate)
ggplot(df_long) +
geom_point(aes(x = side_effects, y = estimate, color = model))+
scale_color_manual(values = c("#0072B2", "goldenrod1", "plum4"),
name = "coefficient for: treatment -> final infarct size",
labels= c("baseline-adjusted censored model", "censored model", "complete model"))+
geom_hline(yintercept = 0, linetype = "dashed", color = "red")+
labs(title = "Estimated values for treatment effect from simulated experiments",
subtitle = "Coefficient value for treatment effect in complete sample, censored sample and baseline-adjusted censored sample",
x= "")+
theme_classic()
####
# We will use another published data set here to create an
# advanced visualisation.
# Does inhalation injury predict mortality in burns patients or require redefinition?
# see  https://doi.org/10.1371/journal.pone.0185195 for publication
#####
library(tidyverse)
library(readxl)
library(knitr)
library(kableExtra)
library(stringr)
# download the publication data from Figshare
url1 <- "https://ndownloader.figshare.com/files/9422038"
p1f <- tempfile()
download.file(url1, p1f, mode = "wb")
# read in data. Note that we need to define the NA
my_data <- read_excel(path = p1f, sheet = 1, na = "NA")
# read in data. Note that we need to define the NA
my_data <- read_excel(path = p1f, sheet = 1, na = "NA")
install.packages("ggforce")
# the data set contains mortaility of patients after burns depending on
# whether and where they had inhalation burns
# first create a new variable that is a
# factor (0=normal, 1=subjective, 2=upper, and 3=lower)
my_data <-
my_data %>%
mutate(INHdiv_fac = factor(INHdiv, labels = c("normal", "subjective", "upper", "lower")))
# create a data frame for a barplot
# group by the new inhalation severity variable and the PFdivide
# ("We also divided the patients into four groups depending on the PF ratio (>300, 200-300, 100-200, and <100)")
# you will need the mean of mortality (look out for spelling mistake) for each level of inhalation injury (INHdiv)
plot_data <-
my_data %>%
group_by(INHdiv_fac, Pfdivide) %>%
summarise(
mean_mort = mean(mortaltiy),
)
plot_data
# create a barplot from this with mean mortality on y axis and Pfdivide on x axis
# create a facet for each severity level
# add error bars
# make nice axis labels
p.1 <- ggplot(aes(y = mean_mort, x = Pfdivide), data = plot_data) +
geom_bar(stat = "identity") +
facet_wrap(~INHdiv_fac) +
theme_classic() +
ylab("Mean mortality") +
xlab(expression("PaO"[2] * "/FiO"[2] * " (PF) ratio"))
p.1
# problem is we transformed a continuous variable to a factorial variable
# is there a way to plot a continuous variable
# if the dependent variable is 0 and 1?
# how about this
names(my_data)[8] <- c("PFratio")
ggplot(aes(y = mortaltiy, x = PFratio), data = my_data) +
geom_point() +
geom_smooth()
# this is not a nice representation!
# we need something better!
# see for example here:
# https://doi.org/10.1890/0012-9623(2004)85[100:ANMOPT]2.0.CO;2
# also as pdf on osf
# first summarise the data in a histogram format
# Summarise data to create histogram counts
# what is the min and max age?
min(my_data$PFratio)
max(my_data$PFratio)
hist_data <-
my_data %>%
# first add new variable breaks  that divides PFRatio in steps of 10
# use the findInterval() function to assign the interval to each data point
mutate(breaks = findInterval(PFratio, seq(20, 935, 10))) %>%
# then group by dead/alive and the breaks
group_by(mortaltiy, breaks) %>%
# count the total number in the groups
summarise(n = n()) %>%
# if patients are dead, we want them to show on top with histogram on top so you need to
# calculate in this case the percentage as 1-percentage
mutate(
pct = ifelse(mortaltiy == 0, n / sum(n), 1 - n / sum(n)),
breaks = seq(20, 935, 10)[breaks]
)
hist_data
tail(hist_data)
ggplot() + # this just sets an empty frame to build upon
# first add a histopgram with geom_segment use the help of geom_segment
geom_segment(
data = hist_data, size = 2, show.legend = FALSE,
aes(x = breaks, xend = breaks, y = mortaltiy, yend = pct, colour = factor(mortaltiy))
) +
# then predict a logistic regression via stat_smooth and the glm method (we will cover the details in the next session)
stat_smooth(data = my_data, aes(y = mortaltiy, x = PFratio), method = "glm", method.args = list(family = "binomial")) +
# some cosmetics
scale_y_continuous(limits = c(-0.02, 1.02)) +
scale_x_continuous(limits = c(10, 950)) +
theme_bw(base_size = 12) +
ylab("Patient Alive=0/Dead=1") +
xlab(expression("PaO"[2] * "/FiO"[2] * " (PF) ratio"))
######
hist_data
ggplot() + # this just sets an empty frame to build upon
# first add a histopgram with geom_segment use the help of geom_segment
geom_segment(
data = hist_data, size = 2, show.legend = FALSE,
aes(x = breaks, xend = breaks, y = mortaltiy, yend = pct, colour = factor(mortaltiy))
)
hist_data <-
my_data %>%
# first add new variable that codes breaks
mutate(breaks = findInterval(PFratio, seq(20, 935, 10))) %>%
# then group by dead/alive and the breaks
group_by(INHdiv_fac, mortaltiy, breaks) %>%
# count
summarise(n = n()) %>%
# if patients are dead, we want them to show on top with histogram on top so you need to
# calculate in this case the percentage as 1-percentage
mutate(pct = ifelse(mortaltiy == 0, n / sum(n), 1 - n / sum(n)), breaks = seq(20, 935, 10)[breaks])
###
hist_data
ggplot() + # this just sets an empty frame to build upon
# set the four panels
facet_wrap(~INHdiv_fac) +
# first add a histopgram with geom_segment use the help of geom_segment
geom_segment(
data = hist_data, size = 2, show.legend = FALSE,
aes(x = breaks, xend = breaks, y = mortaltiy, yend = pct, colour = factor(mortaltiy))
) +
# then predict a logistic regression via stat_smooth and the glm method
# (we will cover the details in the next session)
stat_smooth(data = my_data, aes(y = mortaltiy, x = PFratio), method = "glm", method.args = list(family = "binomial")) +
# some cosmetics
scale_y_continuous(limits = c(-0.02, 1.02)) +
scale_x_continuous(limits = c(10, 950)) +
theme_bw(base_size = 12) +
ylab("Patient Alive=0/Dead=1") +
xlab(expression("PaO"[2] * "/FiO"[2] * " (PF) ratio"))
########
# outlier detection for PF ratio
# check which data points are outliers in boxplot
########
# first create a function
is_outlier <- function(x) {
return(x < quantile(x, 0.25) - 1.5 * IQR(x) | x > quantile(x, 0.75) + 1.5 * IQR(x))
}
# now print outlier labels (in this case the row number)
my_data %>%
mutate(row_number = seq(1:nrow(my_data))) %>%
mutate(outlier = ifelse(is_outlier(PFratio), row_number, as.numeric(NA))) %>%
ggplot(., aes(x = INHdiv_fac, y = PFratio)) +
geom_boxplot() +
geom_text(aes(label = outlier), size = 2, position = position_stack(vjus = 0.1), na.rm = TRUE, hjust = -0.3)
# not ideal but a good starter
library(ggforce)
my_data %>%
mutate(row_number = seq(1:nrow(my_data))) %>%
mutate(outlier = ifelse(is_outlier(PFratio), row_number, as.numeric(NA))) %>%
ggplot(., aes(x = INHdiv_fac, y = PFratio)) +
geom_boxplot() +
geom_sina(aes(x = INHdiv_fac, y = PFratio), method = "counts", scale = F) +
geom_text(aes(label = outlier), size = 2, nudge_x = 0.15, na.rm = TRUE, hjust = -0.3)
my_data %>%
mutate(row_number = seq(1:nrow(my_data))) %>%
mutate(outlier = ifelse(is_outlier(PFratio), row_number, as.numeric(NA))) %>%
ggplot(., aes(x = INHdiv_fac, y = PFratio)) +
geom_boxplot() +
geom_sina(aes(x = INHdiv_fac, y = PFratio), method = "counts", scale = F) +
geom_text(aes(label = outlier), size = 2, nudge_x = 0.15, na.rm = TRUE, hjust = -0.3)
# create a data frame for a barplot
# group by the new inhalation severity variable and the PFdivide
# ("We also divided the patients into four groups depending on the PF ratio (>300, 200-300, 100-200, and <100)")
# you will need the mean of mortality (look out for spelling mistake) for each level of inhalation injury (INHdiv)
plot_data <-
my_data %>%
group_by(INHdiv_fac, Pfdivide) %>%
summarise(
mean_mort = mean(mortaltiy),
)
plot_data
# create a barplot from this with mean mortality on y axis and Pfdivide on x axis
# create a facet for each severity level
# add error bars
# make nice axis labels
p.1 <- ggplot(aes(y = mean_mort, x = Pfdivide), data = plot_data) +
geom_bar(stat = "identity") +
facet_wrap(~INHdiv_fac) +
theme_classic() +
ylab("Mean mortality") +
xlab(expression("PaO"[2] * "/FiO"[2] * " (PF) ratio"))
p.1
# problem is we transformed a continuous variable to a factorial variable
# is there a way to plot a continuous variable
# if the dependent variable is 0 and 1?
# how about this
names(my_data)[8] <- c("PFratio")
ggplot(aes(y = mortaltiy, x = PFratio), data = my_data) +
geom_point() +
geom_smooth()
# this is not a nice representation!
# we need something better!
# see for example here:
# https://doi.org/10.1890/0012-9623(2004)85[100:ANMOPT]2.0.CO;2
# also as pdf on osf
# first summarise the data in a histogram format
# Summarise data to create histogram counts
# what is the min and max age?
min(my_data$PFratio)
max(my_data$PFratio)
hist_data <-
my_data %>%
# first add new variable breaks  that divides PFRatio in steps of 10
# use the findInterval() function to assign the interval to each data point
mutate(breaks = findInterval(PFratio, seq(20, 935, 10))) %>%
# then group by dead/alive and the breaks
group_by(mortaltiy, breaks) %>%
# count the total number in the groups
summarise(n = n()) %>%
# if patients are dead, we want them to show on top with histogram on top so you need to
# calculate in this case the percentage as 1-percentage
mutate(
pct = ifelse(mortaltiy == 0, n / sum(n), 1 - n / sum(n)),
breaks = seq(20, 935, 10)[breaks]
)
ggplot() + # this just sets an empty frame to build upon
# first add a histopgram with geom_segment use the help of geom_segment
geom_segment(
data = hist_data, size = 2, show.legend = FALSE,
aes(x = breaks, xend = breaks, y = mortaltiy, yend = pct, colour = factor(mortaltiy))
) +
# then predict a logistic regression via stat_smooth and the glm method (we will cover the details in the next session)
stat_smooth(data = my_data, aes(y = mortaltiy, x = PFratio), method = "glm", method.args = list(family = "binomial")) +
# some cosmetics
scale_y_continuous(limits = c(-0.02, 1.02)) +
scale_x_continuous(limits = c(10, 950)) +
theme_bw(base_size = 12) +
ylab("Patient Alive=0/Dead=1") +
xlab(expression("PaO"[2] * "/FiO"[2] * " (PF) ratio"))
plot_data
my_data
plot_data
my_data
